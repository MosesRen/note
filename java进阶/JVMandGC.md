# JVM 

## 内存空间

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

1.8以后方法区改为了元空间，并放在了直接内存中。

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

###  Java 虚拟机栈

与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

- StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。
- OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage** Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

#### 方法区和永久代的关系：

只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 

#### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

### 元空间 (MetaSpace) 

类的版本、字段、方法、接口等描述信息，类元信息

### 运行时常量池

常量池信息（用于存放编译期生成的各种字面量和符号引用）

![img](../img/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067-1567339692464.jpg)

### java 符号引用和直接引用

符号引用一般放在常量池中，在编译时，会用符号引用占位，在实际解析的时候才会转化为真正的对象地址。

直接引用：

1：直接指向目标的指针。（个人理解为：指向对象，类变量和类方法的指针）

2：相对偏移量。      （指向实例的变量，方法的指针）

3：一个间接定位到对象的句柄。

### 直接内存

分配的堆外内存，元空间，（常量池分配在堆中）

## JVM对象创建过程

以HotSpot虚拟机为例

### 类的加载，连接和初始化

在使用某个类之前，JVM会确保这个类被加载，连接和初始化。

**加载** 

将类的二进制文件读取到内存中，放入方法区内（1.8为元空间）并在堆区创建一个java.lang.Class对象(符号引用？)

**连接**

+ 验证 检查加载的二进制码是否符合类的规范，包括结构，语法，字节码是否合法，兼容性检查等
+ 准备 为类的静态变量分配内存，并将其初始化为默认值。（默认值）
+ 解析 将符号引用替换为直接引用

**初始化**

在初始化阶段，JVM执行类初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：一是在静态变量的声明处进行初始化；二是在静态代码块中进行初始化。静态变量的声明语句，以及静态代码块都被看作类初始化语句，JVM会按照初始化语句在类文件中的的书写顺序依次执行它们。

**Java虚拟机初始化一个类包含以下步骤：**

1.假如这个类还没有被加载和连接，那么先进行加载和连接。

2.假如类中存在直接父类，并且这个父类还没有被初始化，那么就先初始化直接父类。

3.假如类中存在初始化语句，那么就依次执行。

**初始化时机,主要有以下这些场景会出发类的初始化**（主动使用类或接口时才会出发）

01.创建类的实例。包括new关键字来创建，或者通过反射、克隆及反序列化方式来创建实例。

02.调用类的静态方法。

03.访问某个类或接口的静态变量，或者对该静态变量赋值。

04.使用反射机制来创建某个类或接口对应的java.lang.Class对象。例如Class.forName("Test")操作，如果系统还未初始化Test类，这波操作会导致该Test类被初始化，并返回Test类对应的java.lang.Class对象。

05.初始化一个类的子类，该子类所有的父类都会被初始化。

06.JVM启动时被标明为启动类的类（直接使用java.exe命令运行某个主类）。例如对于“java Test”命令，Test类就是启动类（主类），JVM会先初始化这个主类。

之后就是类的初始化，执行类的构造方法。

finilize() 拯救对象，只触发一次

### 类加载器和双亲委派模型

**类加载器**：

启动类加载器（`Bootstrap ClassLoader`）：由`C++`语言实现（针对`HotSpot`）,负责将存放在`<JAVA_HOME>\lib`目录或`-Xbootclasspath`参数指定的路径中的类库加载到内存中。

其他类加载器：由`Java`语言实现，继承自抽象类`ClassLoader`。如：

- 扩展类加载器（`Extension ClassLoader`）：负责加载`<JAVA_HOME>\lib\ext`目录或`java.ext.dirs`系统变量指定的路径中的所有类库。
- 应用程序类加载器（`Application ClassLoader`）。负责加载用户类路径（`classpath`）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即`ClassNotFoundException`），子加载器才会尝试自己去加载。

**自定义类加载器**

继承ClassLoader类然后覆盖气findClass(String name)方法，指定类名称，返回对类的引用。

## 垃圾回收的判断算法

引用计数法和可达性分析 GCroots对象

### 引用计数法：

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。存在的问题：循环引用

### 可达性分析：

从一些GC roots 的对象为起点，从这些结点向下搜索，结点走过的路径为引用链，如果一个对象到GC roots没有引用链的话，证明这个对象是不可用的，可进行垃圾回收的。

### java 的引用分析

引用的类别：强引用，软引用，弱引用，虚引用

+ 强引用  是指创建一个对象并把这个对象赋给一个引用变量，类似“Object obj=new Object()”这类的引用，普遍存在的引用。
+ 软引用  如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；采用softReference 创建
+ 弱引用  弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。
+ 虚引用  果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。采用 java.lang.ref.PhantomReference表示。

## 收集算法

- 标记清除 效率问题，碎片问题
- 复制算法 容量保证问题
- 标记整理 标记+复制
- 分代整理 新生代复制算法 老年代 标记清除/整理算法

CMS+ParNew ParNew 多线程 新生代垃圾收集器，并行 CMS 老年代垃圾回收 标记清除（哈啰使用的垃圾收集器搭配）

堆内存分配策略：

- 对象优先在eden区上分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代

分代垃圾收集策略：

新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区。

大部分对象在eden区生成，当发生垃圾回收时，先将eden区存活对象复制到一个survivor0区，然后情况eden区。如果s0也放满了，将eden和s0去的存活对象，放到s1区，若s1无法存放s0和eden的对象时，则将对象放入老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。

新生代的GC叫做minorGC，来年代的叫做Major GC即Full GC

## 垃圾收集器

新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge

老年代收集器使用的收集器：Serial Old、Parallel Old、CMS

**Serial收集器（复制算法)**

新生代单线程收集器，标记和清理都是单线程，优点是简单高效。

**Serial Old收集器(标记-整理算法)**

老年代单线程收集器，Serial收集器的老年代版本。

Serial 系列的收集器：优点没有线程交互的开销，简单高效，需要有一个停顿时间，stop the world



**ParNew收集器(复制算法)**

新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。可以和CMS配合。新生代首选垃圾收集器



Paralled系列，**CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。**

**Parallel Scavenge收集器(复制算法)**

并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。

**Parallel Old收集器(标记-整理算法)**

Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先

**CMS**（标记清除）

- **初始标记** stop the world 标记直接与GCroot相连的对象
- **并发标记**（其他线程并行）所标记出来的对象开始逐步遍历这些对象（与GCRoot直接相连或与存活的青年代对象直接相关联的对象）的所引用的对象，并标记 这些对象
- **并发预清理**  减少重标记（Remark）步骤Stop-the-World的时间，由于前面的并发标记为并发的，因此因为会发生改变，改变的空间标记为脏块，将脏块重新标记，使空间变得clean。（可省）
- **重新标记**（系统停顿）由于预清理步骤并发，所以可能无法做到及时标记，所以需要一个stop the world 来完整标记所有对象。
- **并发清理**（其他线程并行）目的是移除所有不用的对象，并且重新声明内存空间的归属等候将来使
- **并发重置**（其他线程并行）CMS内部重置回收器状态，准备进入下一个并发回收周期

**CMS的缺点**：

- 对 CPU 资源敏感；需要有足够CPU资源
- 无法处理浮动垃圾，由于并发标记，用户线程在垃圾清理时依然会产生垃圾，
- 用户线程仍然在运行，必须预留出空间给用户线程使用，需要更大的堆空间。
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

#### 总结

Serial/old 单线程

ParNew 多线程 serial多线程版本，可以和CMS搭配使用 

Parallel scanvenge/old 多线程，吞吐量优先

CMS 真正并发的垃圾收集器

## G1垃圾收集器

### Region

G1的内存结构和传统的内存空间划分有比较的不同。G1将内存划分成了多个大小相等的Region（1MB~32MB），Region逻辑上连续，物理内存地址不连续。同时每个Region被标记成E、S、O、H，分别表示Eden、Survivor、Old、Humongous。

其中E、S属于年轻代，O与H属于老年代。

Humongous表示大对象，一般当分配的对象大小大于等于region的一般是认为是H对象。

**G1** 内存分成小的region 每个reion有各自的分代属性，大小一致 分代不连续，搜索引用时要全盘扫描。

##### Card Table:

- Card Table维护着所有的Card。Card Table的结构是一个字节数组，Card Table用这个数组映射着每一个Card
- Card中对象的引用发生改变时，Card在Card Table数组中对应的值被标记为dirty，就称这个Card被脏化了
- 所以Card Table其实就是映射着内存中的对象，Young GC的时候只需要扫描状态是dirty的card

##### Remembered Set: RSet

- 每一个Region都有自己的RSet
- RSet里面记录了引用——就是其他Region中指向本Region中所有对象的所有引用，也就是谁引用了我的对象
- RSet其实是一个Hash Table，Key是其他的Region的起始地址，Value是一个集合，里面的元素是Card Table 数组中的index，既Card对应的Index，映射到对象的Card地址。
  - 比如A对象在regionA，B对象在regionB，且B.f = A，则在regionA的RSet中需要记录一对键值对，key是regionB的起始地址，Value的值能映射到B所在的Card的地址，所以要查找B对象，就可以通过RSet中记录的卡片来查找该对象

**G1 垃圾回收过程：**